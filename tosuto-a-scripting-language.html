       
<div id="tosuto" class="cnt">
<img src="./assets/tosuto.01e6cbe2d3827717b1dd.png" class="title-image" style="object-fit: scale-down; background-color: rgb(30, 30, 46)"></img>
<h1>t&#x0000014d;suto: a scripting language</h1>
<h2>21 april 2024</h2>
<p>I&apos;ve recently been wanting to get back into making programming languages again, so I&apos;ve started up this project to fulfill that desire. Though I didn&apos;t have a goal for what the project would be, I knew that I wanted it to have a really minimal syntax that, given it was my first language, made at least some sense with good amounts of continuity.</p>
<p>I started off by playing around in my code editor and seeing what looked okay. Inspired by Jai and Odin, I made my function declaration syntax super simple, with just a single colon between the name and the arguments and body. To make the language more concise, I made boolean operators a single keystroke because they&apos;re used much more often (in my daily use) than bitwise operators are. This also makes the ternary operator redundant, as one can simply use ands and ors to build a substitute.</p>
<p>Let&apos;s go over some of the features of the language!</p>
<p>Variable declarations, reassignments, and accesses are like most walrus operator languages. Semicolons are not required at the end of lines.</p>
<code-box><code-lang>t&#x0000014d;suto</code-lang><code-body>a := 3<br/>a = 4<br/></code-body></code-box>
<p>Function declarations are as simple as typing out the name and args. The body can be a single statement with an arrow, or a block with curlies. The last statement is implicitly returned, but the ret keyword can be used to return early.</p>
<code-box><code-lang>t&#x0000014d;suto</code-lang><code-body>add : a b -&gt; a + b<br/>multiply : a b {<br/>  a * b<br/>}<br/></code-body></code-box>
<p>Because I wanted to try experimenting with different languages, identifiers follow the rules specified in Microsoft&apos;s MSVC extensions.</p>
<code-box><code-lang>t&#x0000014d;suto</code-lang><code-body>&#x0000ff84;&#x0000ff70;&#x0000ff7d;&#x0000ff84; := "toast"<br/>toast := "toast"<br/>pain_grill&#x000000e9; := "toast"<br/></code-body></code-box>
<p>Objects are very minimal and are similar to Lua&apos;s tables, where calling a member function with a colon will pass the object as the first parameter. This first parameter can be called anything, which allows greater flexibility when making constructors or other special functions.</p>
<code-box><code-lang>t&#x0000014d;suto</code-lang><code-body>vec2 := [|<br/>  new : base x y -&gt; base with [|x = x, y = y|]<br/>  dot : my other -&gt; my.x * other.x + my.y * other.y<br/>  // ... other stuff<br/>|]<br/><br/>vec := vec2:new(1, 2)<br/>test_dot = vec:dot(vec2:new(3, 3))<br/></code-body></code-box>
<p>Note the use of the <code-span>with</code-span> keyword in the previous example. This allows easy construction of objects, using the existing object as a template for the constructed object, and a second object that is appended to the first. Though this is nowhere near the most efficient way to do things, it&apos;s definitely one of the easiest to implement!</p>
<p>The language uses a custom bytecode and vm that I implemented based on the one in Crafting Interpreters, which I optimized heavily. During this optimization, I rewrote the vm to move away from the C++ class based implementation that I previously used and returned to the land of C, which, in my opinion, turns out to be much nicer and easier to write bytecode interpreters in, anyway.</p>
<p>Unlike the implementation in Crafting Interpreters, I adapted the vm from my original tree-walk interpreter. This means that my compiler works in stages, instead of the CI implementation which lexed, parsed, and compiled the source file in one step. The compiler works remarkably similarly to the tree-walk interpreter as a result, working recursively down the tree of nodes. However, instead of running the code, it spits out bytecode, an example of which can be seen below.</p>
<code-box><code-lang>t&#x0000014d;suto bytecode</code-lang><code-body>anonymous:<br/>0000	lit_16	<function &#x0000ff8c;&#x0000ff68;&#x0000ff8e;&#x0000ff9e;><br/>0003	glob_d	&#x0000ff8c;&#x0000ff68;&#x0000ff8e;&#x0000ff9e;<br/>0006	glob_g	&#x0000ff8c;&#x0000ff68;&#x0000ff8e;&#x0000ff9e;<br/>0009	lit_8	9.000000<br/>0011	call	1<br/>0013	pop<br/>0014	ret<br/><br/>anonymous.&#x0000ff8c;&#x0000ff68;&#x0000ff8e;&#x0000ff9e;:<br/>0000	loc_g	1<br/>0003	lit_8	2.000000<br/>0005	lt	<br/>0006	jmpf	4	(6-&gt;13)<br/>0009	pop	<br/>0010	loc_g	1<br/>0013	jmpf	3	(13-&gt;19)<br/>0016	jmp	23	(16-&gt;42)<br/>0019	pop	<br/>0020	glob_g	&#x0000ff8c;&#x0000ff68;&#x0000ff8e;&#x0000ff9e;<br/>0023	loc_g	1<br/>0026	ld_1	<br/>0027	sub	<br/>0028	call	1<br/>0030	glob_g	&#x0000ff8c;&#x0000ff68;&#x0000ff8e;&#x0000ff9e;<br/>0033	loc_g	1<br/>0036	lit_8	2.000000<br/>0038	sub	<br/>0039	call	1<br/>0041	add	<br/>0042	ret	<br/></code-body></code-box>
<p>That&apos;s as far as I&apos;ve gone with the project so far. I still have ideas for things I want to do with it, though, ranging from trying to write a more complete standard library for it to making an ahead-of-time compiler for it.</p>
<separator></separator><p>That&apos;s the end of this post. Thanks for reading!<br/><a href="#intro">Back to top &#x2934;</a></p>
</div>
