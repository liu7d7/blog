       
<div id="truchet" class="cnt">
<img src="./assets/firefox_4AGEoABwFr.jpg" class="title-image"></img>
<h1>shadertoy 1: truchet</h1>
<h2>18 may 2025</h2>
<p>Wow, it&apos;s been more than a year since my last blog post. I suppose that&apos;s fitting, though, since this year&apos;s been a doozy.</p>
<p>Well, I have some more time now, and I&apos;ve got so much energy to try some new stuff. I&apos;ve been inspired especially by some graphics programming demos that were posted in our CS Club&apos;s show-and-tell channel, as well as Revision Demoparty&apos;s Shader Showdown. I still remember the first time I saw live shader coding; I was genuinely amazed at how much they were able to pull off in just 25 minutes, as well as the level of polish they were able to deliver.</p>
<p>Revision 2025 just happened, and Shader Showdown was once again pretty awesome. While the main event was the addition of compute shaders, one part of Flopine&apos;s submission really caught my eye.</p>
<img src="./assets/chrome_RuryzLBmsZ.png" class="other-image"></img>
<p>It&apos;s such an elegant pattern, and I wanted to go through my own process of making it in the most optimized way. In the end, I learned things I never knew about GLSL and discovered the really welcoming community on Shadertoy.</p>
<h3>My first attempt</h3>
<iframe frameborder="0" src="https://www.shadertoy.com/embed/tcc3z2?gui=true&t=10&paused=true&muted=false" allowfullscreen style="aspect-ratio: 16/9"></iframe>
<p>The general idea is as follows:</p>
<ul>
  <li>For each pixel, find which cell it&apos;s in; each cell is <code-span>w</code-span> wide.</li>
  <li>Find the hash at the bottom left of the cell mod 4.</li>
  <li>Index into an array that decides the two points about which we&apos;re making circles</li>
  <li>Draw the circles with some nice glow</li>
  <li>Repeat this for different scales with some nice blending!</li>
</ul>
<code-box><code-lang>glsl</code-lang><code-body>vec4<br/>truchet(vec2 p, float r, float w)<br/>{<br/>  float hr = r / 2.;<br/>  float hw = w / 2.;<br/><br/>  vec2 b = floor(p / r) * r;<br/>  vec2 c = b + vec2(hr);<br/>  uint h = hash(uvec2(abs(c * 100.))) % 4u;<br/><br/>  vec2 a[] = vec2[](<br/>    b + vec2(r, 0),<br/>    b + vec2(r),<br/>    b + vec2(0, r),<br/>    b,<br/>    b + vec2(0, r),<br/>    b,<br/>    b + vec2(r, 0),<br/>    b + vec2(r)<br/>  );<br/><br/>  float d = distance(p, a[h]);<br/>  if (abs(d - hr) &lt; hw) {<br/>    return vec4(1.);<br/>  }<br/><br/>  if (abs(d - hr) &lt; w * 1.5) {<br/>    return vec4(color(iTime * 0.5), (1. - (abs(d - hr) - hw) / w) * 0.5);<br/>  }<br/><br/>  d = distance(p, a[h + 4u]);<br/>  if (abs(d - hr) &lt; hw) {<br/>    return vec4(1.);<br/>  }<br/><br/>  if (abs(d - hr) &lt; w * 1.5) {<br/>    return vec4(color(iTime * 0.5), (1. - (abs(d - hr) - hw) / w) * 0.5);<br/>  }<br/>  return vec4(0.);<br/>}</code-body></code-box>
<p>The issue here, as FabriceNeyret2 pointed out in their comment, is that arrays are slow in GLSL, and that I&apos;m not doing any antialiasing &lpar;which I can get for free!&rpar;. Surely, I could find a new way to fix these issues.</p>
<h3>My second go</h3>
<iframe frameborder="0" src="https://www.shadertoy.com/embed/tctGRf?gui=true&t=10&paused=true&muted=false" allowfullscreen style="aspect-ratio: 16/9"></iframe>
<p>Now we&apos;re talking. Let&apos;s take a look at what&apos;s different now!</p>
<code-box><code-lang>glsl</code-lang><code-body>vec4<br/>truchet(vec2 p, float r, float w)<br/>{<br/>  float hr = r / 2.;<br/>  float hw = w / 2.;<br/><br/>  vec2 b = floor(p / r) * r;<br/>  vec2 c = b + vec2(hr);<br/>  float h = float(hash(uvec2(abs(c * 100.))) % 4u);<br/>  float i = 3. - h;<br/><br/>  vec2 a0 = b + vec2(mod(h, 2.) * r, floor(h / 2.) * r);<br/>  vec2 a1 = b + vec2(mod(i, 2.) * r, floor(i / 2.) * r);<br/><br/>  float d1 = distance(p, a0);<br/>  float d2 = distance(p, a1);<br/><br/>  float d = min(d1, d2);<br/><br/>  vec4 glow = vec4(<br/>    color(triangle(iTime * 0.125, 3., 1.)), <br/>    (1. - (abs(d - hr) - hw) / w) * 0.5<br/>  );<br/><br/>  return mix(vec4(1.), glow, smoothstep(hw, hw + 1.414, abs(d - hr)));<br/>}</code-body></code-box>
<p>Alright, so I got rid of the array! Instead, we have some math. The idea is that we pick a hash the same way as above, but instead of indexing into an array, we treat that hash as one of the four corners of our cell! Then, once we pick one corner of our cell, we can pick the diagonally opposing corner using <code-span>3 - h</code-span> where <code-span>h</code-span> is the first corner we picked.</p>
<img src="./assets/truchet_expl.png" class="other-image"></img>
<h3>Final product</h3>
<p>Check out the full shader on <a href="https://www.shadertoy.com/view/tctGRf">Shadertoy</a>!</p>
<separator></separator><p>That&apos;s the end of this post. Thanks for reading!<br/><a href="#intro">Back to top &#x2934;</a></p>
</div>
